#!/bin/bash
# Strict mode
set -euo pipefail
set +x
trap 'echo "Interrupted, exiting..." >&2; exit 1' INT TERM

# Constants
readonly LITE_DEPTH=30000
readonly STATE_ROOT_CHECK_COUNT=899 # Check 900-1
readonly LINK_CHECK_COUNT=900
export JOB_NAME="validate-snapshots"

source /scripts/helpers.sh
source /scripts/metrics.sh

fetch_snapshot_name() {
  local height="$1"
  local snapshot
  snapshot=$(find "${LITE_SNAPSHOT_DIR}" -type f -name "*${height}*.forest.car.zst" | head -n1)
  if [[ ! -f "${snapshot}" ]]; then
    error "Error: No snapshot found for height ${height}"
  fi
  echo "${snapshot}"
}

validate_snapshot() {
  local snapshot="$1"
  local current_epoch="$2"
  info "Validating ${snapshot}"
  local start_time=${SECONDS}
  if forest-tool snapshot validate \
    --check-stateroots $STATE_ROOT_CHECK_COUNT \
    --check-links $LINK_CHECK_COUNT \
    "${snapshot}" >/dev/null; then
    info "Lite snapshot ${snapshot} for ${current_epoch} is valid"
    increment_success_counter
    update_process_duration "$((SECONDS - start_time))"
    return 0
  else
    warning "Snapshot ${snapshot} for ${current_epoch} is invalid"
    increment_failure_counter
    update_process_duration "$((SECONDS - start_time))"
    return 1
  fi
}

process_snapshot() {
  local current_epoch="$1"
  local snapshot
  snapshot=$(fetch_snapshot_name "$current_epoch")

  if validate_snapshot "${snapshot}" "${current_epoch}"; then
    # Store validated height in cache
    rabbit_produce "validated" "${current_epoch}"
  else
    local error_message="Validation of ${current_epoch} failed"
    slack_notify "${error_message}" "failure"
    rabbit_produce "validated-failed" "${current_epoch}"
    error "${error_message}"
  fi
}

process_epochs() {
  local last_validated_epoch="$1"
  local last_downloaded_epoch
  local last_built_epoch
  local full_start_time=${SECONDS}
  local current=$((last_validated_epoch + LITE_DEPTH))
  update_total_epochs_metric "$END_EPOCH"

  while true; do
    last_downloaded_epoch=$(rabbit_consume_latest_with_default "downloaded" "{{ forest.download_snapshots.start_epoch }}")
    last_built_epoch=$(rabbit_consume_latest_with_default "created" "{{ forest.build_snapshots.start_epoch }}")
    if ((last_downloaded_epoch >= current)) || ((last_built_epoch >= current)) ; then
      local batch_start_time=${SECONDS}
      local batch_end=$((current + LITE_DEPTH))
      info "Validating epochs ${current} to ${batch_end} on ${CHAIN}"

      update_progress_metric "$current"
      process_snapshot "$current"

      local progress
      progress="$(progress_info "$current" "${END_EPOCH}" "$LITE_DEPTH" "$full_start_time" "$batch_start_time")"
      info "${progress}"
      slack_notify "${progress}" "success"
      current=$((current + LITE_DEPTH))
      continue
    else
      warning "Epoch ${current} is not created yet. Waiting 30 minutes ..."
      sleep $((60*30))
    fi
  done
}

main() {
  setup_metrics
  start_metrics_server

  rabbit_setup "validated"
  local last_validated_epoch
  last_validated_epoch=$(rabbit_consume_latest_with_default "validated" "{{ forest.validate_snapshots.start_epoch }}")
  last_validated_epoch=$((last_validated_epoch - (last_validated_epoch % LITE_DEPTH)))

  init_folders
  process_epochs "$last_validated_epoch"
}

main
